<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Topic Info Storage</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
<style>
  :root {
    /* Color Palette (kept as per your request) */
    --primary-dark: #2c3e50;
    --secondary-dark: #34495e;
    --hover-dark: #3d5a73; /* Slightly adjusted for better contrast */
    --main-bg: #f9fbfd; /* Very light, almost white for freshness */
    --text-color: #333;
    --light-text: #ecf0f1;
    --accent-blue: #2980b9;
    --accent-blue-light: #3498db; /* Used for subtle highlights */
    --accent-green: #27ae60;
    --accent-yellow: #f1c40f;
    --accent-red: #e74c3c;

    /* Spacing & Sizes */
    --spacing-xs: 6px;
    --spacing-sm: 12px;
    --spacing-md: 18px;
    --spacing-lg: 24px;
    --spacing-xl: 36px;

    /* Border Radius */
    --border-radius-sm: 6px;
    --border-radius-md: 10px; /* More rounded */
    --border-radius-lg: 15px; /* Even more rounded for cards */

    /* Shadows (softer and more modern) */
    --shadow-soft: 0 4px 12px rgba(0, 0, 0, 0.08);
    --shadow-deep: 0 8px 20px rgba(0, 0, 0, 0.15);
    --shadow-inset: inset 0 1px 3px rgba(0, 0, 0, 0.05); /* For input fields */
  }

  body {
    font-family: 'Poppins', sans-serif; /* More playful, modern font */
    display: flex;
    min-height: 100vh;
    margin: 0;
    user-select: none;
    color: var(--text-color);
    background-color: var(--main-bg);
    overflow: hidden; /* Prevent body scroll, let specific divs scroll */
  }

  /* Sidebar Styles */
  .sidebar {
    width: 300px; /* Wider for more comfortable reading */
    background-color: var(--primary-dark);
    padding: var(--spacing-lg) var(--spacing-md); /* Consistent padding */
    color: var(--light-text);
    overflow-y: auto;
    position: relative;
    box-shadow: var(--shadow-deep); /* More prominent shadow for depth */
    border-radius: 0 var(--border-radius-lg) var(--border-radius-lg) 0; /* Rounded right side */
    display: flex;
    flex-direction: column; /* For stickying add topic button */
  }

  .sidebar h2 {
    font-size: 1.4em; /* Slightly larger heading */
    margin-bottom: var(--spacing-md);
    padding-bottom: var(--spacing-sm);
    border-bottom: 1px solid rgba(255, 255, 255, 0.15); /* Slightly stronger separator */
    font-weight: 600;
    letter-spacing: 0.8px;
    user-select: text;
    text-shadow: 0 1px 2px rgba(0,0,0,0.2); /* Subtle text shadow */
  }

  .topic {
    margin-bottom: var(--spacing-sm);
  }

  .topic-header {
    display: flex;
    align-items: center;
    gap: var(--spacing-xs);
  }

  .topic-button {
    flex-grow: 1;
    padding: var(--spacing-sm) var(--spacing-md);
    background-color: var(--secondary-dark);
    color: var(--light-text);
    border: none;
    border-radius: var(--border-radius-md); /* More rounded buttons */
    cursor: pointer;
    text-align: left;
    font-size: 1em; /* Clearer font size */
    font-weight: 500;
    transition: background-color 0.25s ease, transform 0.15s ease, box-shadow 0.25s ease;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Subtle button shadow */
  }

  .topic-button:hover {
    background-color: var(--hover-dark);
    transform: translateY(-2px); /* Lift effect */
    box-shadow: 0 4px 8px rgba(0,0,0,0.3); /* Enhanced shadow on hover */
  }

  .subtopics-dropdown {
    display: none;
    padding-left: var(--spacing-lg); /* Deeper indent */
    margin-top: var(--spacing-xs);
  }

  .subtopics-dropdown ul {
    list-style-type: none; /* No default bullets */
    margin: 0;
    padding: 0;
  }

  .subtopic-list-item {
    display: flex;
    align-items: center;
    margin-bottom: var(--spacing-xs);
    border-left: 3px solid rgba(255, 255, 255, 0.2); /* Thicker, more visible line */
    padding-left: var(--spacing-sm);
    transition: border-color 0.2s ease;
  }

  .subtopic-list-item:hover {
    border-color: var(--accent-yellow); /* Highlight border on hover */
  }

  .subtopic-button {
    flex-grow: 1;
    background: none;
    border: none;
    color: var(--light-text);
    font-size: 0.95em;
    cursor: pointer;
    text-align: left;
    padding: var(--spacing-xs);
    transition: color 0.2s ease, text-decoration 0.2s ease;
    font-weight: 400;
  }

  .subtopic-button:hover {
    color: var(--accent-yellow);
    text-decoration: underline;
  }

  /* Icon Buttons */
  .icon-btn {
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.7); /* Slightly brighter initial color */
    cursor: pointer;
    font-size: 1.15em; /* Larger icons */
    padding: var(--spacing-xs);
    transition: color 0.2s ease, transform 0.15s ease;
    border-radius: var(--border-radius-sm); /* Small radius for click area */
  }

  .icon-btn:hover {
    color: var(--accent-red);
    transform: scale(1.15); /* More pronounced scaling */
  }
  .icon-rename:hover {
    color: var(--accent-yellow);
  }
  .icon-btn.add-sub-btn { /* Specific styles for the add subtopic button if needed */
      color: var(--accent-green); /* Always green */
  }
  .icon-btn.add-sub-btn:hover {
      color: var(--accent-green); /* Ensure it stays green on hover */
      transform: scale(1.15) rotate(90deg); /* Playful rotate effect */
  }

  /* Main Content Styles */
  .main-content {
    flex: 1;
    padding: var(--spacing-xl); /* Generous padding */
    background-color: var(--main-bg);
    position: relative;
    overflow-y: auto;
    user-select: text;
  }

  .main-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--spacing-lg);
    padding-bottom: var(--spacing-md);
    border-bottom: 1px solid #e0e0e0;
  }

  .main-header h1 {
    font-size: 2.2em; /* Bigger, bolder title */
    margin: 0;
    font-weight: 700;
    color: var(--primary-dark);
    text-shadow: 0 2px 3px rgba(0,0,0,0.05); /* Subtle shadow for heading */
  }

  #edit-toggle-btn {
    background-color: var(--accent-blue);
    color: white;
    border: none;
    padding: var(--spacing-sm) var(--spacing-md);
    font-size: 1em;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.15s ease, box-shadow 0.2s ease;
    user-select: none;
    font-weight: 500;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  }
  #edit-toggle-btn:hover {
    background-color: var(--accent-blue-light); /* Lighter on hover */
    transform: translateY(-3px); /* More lift */
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  }
  #edit-toggle-btn:active {
      transform: translateY(0); /* Press effect */
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
  }

  /* Right Panel Content */
  .subtopic-links {
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-lg);
    padding-bottom: var(--spacing-md);
    border-bottom: 1px solid #ebf0f5; /* Lighter separator */
  }

  .subtopic-link {
    background-color: #e6eff7; /* Softer, slightly blue background */
    color: var(--primary-dark);
    border: none;
    border-radius: var(--border-radius-sm);
    padding: var(--spacing-xs) var(--spacing-sm);
    font-size: 0.95em;
    cursor: pointer;
    transition: background-color 0.2s ease, color 0.2s ease, transform 0.1s ease;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }

  .subtopic-link:hover {
    background-color: var(--accent-blue);
    color: white;
    transform: translateY(-1px);
  }
  .main-content h2 { /* Subtopic header */
      font-size: 1.8em; /* Larger subtopic heading */
      color: var(--secondary-dark);
      margin-bottom: var(--spacing-md);
      font-weight: 600;
      letter-spacing: 0.5px;
  }

  /* --- Editor Specific Styles --- */
  .editor-container { /* This will now wrap both toolbar and editor content */
    position: relative; /* For positioning the save icon */
    margin-top: var(--spacing-md);
    border-radius: var(--border-radius-lg);
    box-shadow: var(--shadow-soft); /* Apply shadow to the whole container */
    overflow: hidden; /* Ensures border-radius is respected by inner elements */
  }

  /* Quill-specific styling adjustments */
  .ql-toolbar {
    background-color: #eef3f7; /* Lighter toolbar background */
    border: none; /* Removed border, as container has it */
    border-bottom: 1px solid #ddd; /* Separator between toolbar and editor */
    padding: var(--spacing-sm);
  }

  .ql-container {
    min-height: 250px; /* Match desired min-height */
    border: none; /* Removed border, as container has it */
    font-size: 1.05em; /* Inherit global font size */
    color: var(--text-color); /* Inherit global text color */
    line-height: 1.7; /* Inherit global line height */
    font-family: 'Poppins', sans-serif; /* Apply your font within the editor */
  }

  .ql-editor {
    min-height: 250px; /* Ensure editor content area respects min height */
    padding: var(--spacing-lg); /* Consistent padding */
    box-sizing: border-box; /* Include padding in width */
  }

  /* Read-only content display */
  .read-only-content {
      border: 1px solid #e0e0e0;
      padding: var(--spacing-lg);
      min-height: 250px;
      background-color: white;
      border-radius: var(--border-radius-lg);
      font-size: 1.05em;
      color: var(--text-color);
      white-space: pre-wrap; /* Preserve formatting for pre-formatted text */
      overflow-wrap: break-word;
      line-height: 1.7;
      box-shadow: var(--shadow-soft);
      margin-top: var(--spacing-md); /* Match spacing of editor container */
      user-select: text;
  }


  /* Focus style for Quill editor */
  .ql-container.ql-focused {
      border-color: var(--accent-blue-light); /* Apply focus to the editor-container */
      box-shadow: 0 0 0 4px rgba(52, 152, 219, 0.25), var(--shadow-soft);
  }

  /* Styling for Quill buttons/icons for consistency with theme */
  .ql-toolbar button, .ql-toolbar .ql-picker {
      color: var(--primary-dark); /* Darker icon color */
      transition: background-color 0.2s ease, color 0.2s ease;
  }
  .ql-toolbar button:hover, .ql-toolbar .ql-picker:hover,
  .ql-toolbar button.ql-active, .ql-toolbar .ql-picker.ql-active {
      background-color: rgba(52, 152, 219, 0.1); /* Light blue hover/active */
      color: var(--accent-blue);
  }
  .ql-toolbar .ql-stroke { /* For Quill's SVG icons */
      stroke: var(--primary-dark);
  }
  .ql-toolbar button:hover .ql-stroke, .ql-toolbar button.ql-active .ql-stroke {
      stroke: var(--accent-blue);
  }
  .ql-toolbar .ql-fill { /* For Quill's SVG icons */
      fill: var(--primary-dark);
  }
  .ql-toolbar button:hover .ql-fill, .ql-toolbar button.ql-active .ql-fill {
      fill: var(--accent-blue);
  }
  /* Specific override for header dropdown text */
  .ql-picker.ql-header .ql-picker-label[data-value="1"]::before { content: 'Heading 1'; }
  .ql-picker.ql-header .ql-picker-item[data-value="1"]::before { content: 'Heading 1'; }
  .ql-picker.ql-header .ql-picker-label[data-value="2"]::before { content: 'Heading 2'; }
  .ql-picker.ql-header .ql-picker-item[data-value="2"]::before { content: 'Heading 2'; }
  .ql-picker.ql-header .ql-picker-label[data-value="3"]::before { content: 'Heading 3'; }
  .ql-picker.ql-header .ql-picker-item[data-value="3"]::before { content: 'Heading 3'; }
  .ql-picker.ql-header .ql-picker-label::before { content: 'Normal'; }
  .ql-picker.ql-header .ql-picker-item::before { content: 'Normal'; }


  .save-icon {
    position: absolute;
    top: var(--spacing-xs); /* Adjust based on toolbar height */
    right: var(--spacing-xs); /* Adjust padding */
    width: 32px;
    height: 32px;
    cursor: pointer;
    fill: var(--accent-green);
    display: none;
    transition: fill 0.3s ease, transform 0.2s ease;
    z-index: 10; /* Ensure it's above Quill's toolbar elements */
  }

  .save-icon:hover {
    fill: var(--accent-green);
    transform: scale(1.2) rotate(5deg);
  }
  .save-icon:active {
      transform: scale(1.1);
  }


  /* Password Prompt */
  #password-prompt {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.75);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    visibility: hidden;
    opacity: 0;
    transition: opacity 0.3s ease, visibility 0.3s ease;
    backdrop-filter: blur(5px);
  }
  #password-prompt.visible {
    visibility: visible;
    opacity: 1;
  }
  #password-box {
    background: white;
    padding: var(--spacing-xl);
    border-radius: var(--border-radius-lg);
    box-shadow: var(--shadow-deep);
    text-align: center;
    width: 380px;
    max-width: 90%;
    transform: translateY(-30px) scale(0.95);
    transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.3s ease;
  }
  #password-prompt.visible #password-box {
    transform: translateY(0) scale(1);
  }
  #password-box h2 {
    font-size: 1.6em;
    margin-top: 0;
    margin-bottom: var(--spacing-lg);
    color: var(--primary-dark);
    font-weight: 600;
  }
  #password-box input[type="password"] {
    width: calc(100% - 2 * var(--spacing-sm));
    padding: var(--spacing-sm) var(--spacing-md);
    font-size: 1.1em;
    margin: var(--spacing-md) 0 var(--spacing-lg) 0;
    border-radius: var(--border-radius-sm);
    border: 1px solid #ddd;
    box-shadow: var(--shadow-inset);
    box-sizing: border-box;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }
  #password-box input[type="password"]:focus {
      border-color: var(--accent-blue-light);
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.15);
  }
  #password-box button {
    background-color: var(--accent-blue);
    color: white;
    border: none;
    padding: var(--spacing-sm) var(--spacing-lg);
    font-size: 1.1em;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.15s ease, box-shadow 0.2s ease;
    font-weight: 500;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  }
  #password-box button:hover {
    background-color: var(--accent-blue-light);
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  }
  #password-box button:active {
      transform: translateY(0);
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
  }
  #password-error {
    color: var(--accent-red);
    font-size: 0.9em;
    height: 1.5em;
    margin-bottom: var(--spacing-sm);
    font-weight: 500;
  }

  /* Add New Topic button style */
  #add-topic-btn {
    display: none;
    margin-top: auto;
    background-color: var(--accent-green);
    color: white;
    border: none;
    padding: var(--spacing-md);
    font-size: 1.1em;
    border-radius: var(--border-radius-md);
    cursor: pointer;
    user-select: none;
    font-weight: 600;
    letter-spacing: 0.5px;
    transition: background-color 0.25s ease, transform 0.15s ease, box-shadow 0.25s ease;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
  }
  #add-topic-btn:hover {
    background-color: var(--accent-green);
    transform: translateY(-3px);
    box-shadow: 0 6px 15px rgba(0,0,0,0.3);
  }
  #add-topic-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  }
</style>
<script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>

<!-- Firebase (module) -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
  import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyBUGeaEh7NTVxKbJVgxCzHm17vuFAXQrno",
    authDomain: "website-46afd.firebaseapp.com",
    projectId: "website-46afd",
    storageBucket: "website-46afd.firebasestorage.app",
    messagingSenderId: "14135336524",
    appId: "1:14135336524:web:d1446bec8a546144921ee9"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  // Expose Firestore + helpers globally for the main script
  window._db = db;
  window._doc = doc;
  window._getDoc = getDoc;
  window._setDoc = setDoc; // expose globally so your other script can use them
</script>
</head>
<body>
  <div class="sidebar" id="sidebar">
    <h2>Topics</h2>
    <button id="add-topic-btn" title="Add New Topic">+ Add New Topic</button>
  </div>

  <div class="main-content" id="main-content">
    <div class="main-header">
      <h1 id="current-topic-header">Select a topic</h1>
      <button id="edit-toggle-btn" onclick="toggleEditMode()">Edit</button>
    </div>
    <div id="right-panel"></div>
  </div>

  <div id="password-prompt">
    <div id="password-box">
      <h2>Enter Password to Edit</h2>
      <input type="password" id="password-input" placeholder="Password" />
      <div id="password-error"></div>
      <button onclick="checkPassword()">Unlock Editing</button>
    </div>
  </div>

<script>
  const EDIT_PASSWORD = 'sam'; // password

  let topics = [];
  let currentTopicIndex = null;
  let currentSubtopicIndex = null;
  let editingUnlocked = false;
  let quillEditor = null; // Variable to hold the Quill editor instance

  const sidebar = document.getElementById('sidebar');
  const rightPanel = document.getElementById('right-panel');
  const passwordPrompt = document.getElementById('password-prompt');
  const passwordInput = document.getElementById('password-input');
  const passwordError = document.getElementById('password-error');
  const editToggleBtn = document.getElementById('edit-toggle-btn');
  const addTopicBtn = document.getElementById('add-topic-btn');

  // Load topics from localStorage or defaults
  function loadTopics() {
    const saved = localStorage.getItem('topics');
    if (saved) {
      try {
        topics = JSON.parse(saved);
      } catch {
        topics = getDefaultTopics();
      }
    } else {
      topics = getDefaultTopics();
    }
  }

  function saveTopics() {
    localStorage.setItem('topics', JSON.stringify(topics));
  }

  function getDefaultTopics() {
    return [
      { name: "Getting Started", subtopics: ["Welcome!", "How to Use", "Tips & Tricks"] },
      { name: "My Ideas", subtopics: ["Project Alpha", "Brainstorming Session", "Future Concepts"] },
      { name: "Study Notes", subtopics: ["Math Fundamentals", "History Key Dates", "Science Experiments"] },
    ];
  }

  // Render sidebar with topics and dropdown subtopics with rename/remove/add icons
  function renderSidebar() {
    const addBtnRef = addTopicBtn;
    sidebar.innerHTML = '<h2>Topics</h2>';
    
    const topicsContainer = document.createElement('div');
    topicsContainer.style.flexGrow = '1';
    topicsContainer.style.overflowY = 'auto';
    topicsContainer.style.marginBottom = 'var(--spacing-md)';

    topics.forEach((topic, idx) => {
      const topicDiv = document.createElement('div');
      topicDiv.className = 'topic';

      const topicHeader = document.createElement('div');
      topicHeader.className = 'topic-header';

      const topicBtn = document.createElement('button');
      topicBtn.className = 'topic-button';
      topicBtn.textContent = topic.name;
      topicBtn.dataset.type = 'topic';
      topicBtn.dataset.topicIndex = idx;
      topicBtn.onclick = () => {
        toggleSubtopics(`sub${idx}`);
        loadTopic(idx);
      };
      topicBtn.oncontextmenu = e => e.preventDefault();

      topicHeader.appendChild(topicBtn);

      if(editingUnlocked){
        const renameBtn = document.createElement('button');
        renameBtn.className = 'icon-btn icon-rename';
        renameBtn.title = 'Rename Topic';
        renameBtn.innerHTML = '&#9998;';
        renameBtn.onclick = e => {
          e.stopPropagation();
          renameTopic(idx);
        };
        topicHeader.appendChild(renameBtn);

        const removeBtn = document.createElement('button');
        removeBtn.className = 'icon-btn';
        removeBtn.title = 'Remove Topic';
        removeBtn.innerHTML = '&#10060;';
        removeBtn.onclick = e => {
          e.stopPropagation();
          if(confirm(`Delete topic "${topic.name}" and all its subtopics?`)){
            removeTopic(idx);
          }
        };
        topicHeader.appendChild(removeBtn);

        const addSubBtn = document.createElement('button');
        addSubBtn.className = 'icon-btn add-sub-btn';
        addSubBtn.title = 'Add New Subtopic';
        addSubBtn.innerHTML = '&#10133;';
        addSubBtn.onclick = e => {
          e.stopPropagation();
          addSubtopic(idx);
        };
        topicHeader.appendChild(addSubBtn);
      }

      topicDiv.appendChild(topicHeader);

      const subDiv = document.createElement('div');
      subDiv.className = 'subtopics-dropdown';
      subDiv.id = `sub${idx}`;

      const ul = document.createElement('ul');
      topic.subtopics.forEach((sub, sidx) => {
        const li = document.createElement('li');
        li.className = 'subtopic-list-item';

        const subBtn = document.createElement('button');
        subBtn.className = 'subtopic-button';
        subBtn.textContent = sub;
        subBtn.dataset.type = 'subtopic';
        subBtn.dataset.topicIndex = idx;
        subBtn.dataset.subtopicIndex = sidx;
        subBtn.onclick = () => showSubcontent(idx, sidx);
        subBtn.oncontextmenu = e => e.preventDefault();

        li.appendChild(subBtn);

        if(editingUnlocked){
          const renameSubBtn = document.createElement('button');
          renameSubBtn.className = 'icon-btn icon-rename';
          renameSubBtn.title = 'Rename Subtopic';
          renameSubBtn.innerHTML = '&#9998;';
          renameSubBtn.onclick = e => {
            e.stopPropagation();
            renameSubtopic(idx, sidx);
          };
          li.appendChild(renameSubBtn);

          const removeSubBtn = document.createElement('button');
          removeSubBtn.className = 'icon-btn';
          removeSubBtn.title = 'Remove Subtopic';
          removeSubBtn.innerHTML = '&#10060;';
          removeSubBtn.onclick = e => {
            e.stopPropagation();
            if(confirm(`Delete subtopic "${sub}"?`)){
              removeSubtopic(idx, sidx);
            }
          };
          li.appendChild(removeSubBtn);
        }

        ul.appendChild(li);
      });

      subDiv.appendChild(ul);
      topicDiv.appendChild(subDiv);
      topicsContainer.appendChild(topicDiv);
    });

    sidebar.appendChild(topicsContainer);
    sidebar.appendChild(addBtnRef);

    addTopicBtn.style.display = editingUnlocked ? 'block' : 'none';
  }

  function toggleSubtopics(id) {
    const el = document.getElementById(id);
    if(!el) return;
    el.style.display = el.style.display === 'block' ? 'none' : 'block';
  }

  function loadTopic(index) {
    currentTopicIndex = index;
    currentSubtopicIndex = null;
    const topic = topics[index];
    document.getElementById('current-topic-header').textContent = topic.name;

    rightPanel.innerHTML = ''; // Clear previous content

    // Destroy existing Quill editor if it's active
    if (quillEditor) {
        quillEditor = null; // Unsetting reference is sufficient.
    }

    const subtopicList = document.createElement('div');
    subtopicList.className = 'subtopic-links';

    const uniqueSubtopics = [...new Set(topic.subtopics)];

    uniqueSubtopics.forEach(sub => {
      const btn = document.createElement('button');
      btn.className = 'subtopic-link';
      btn.textContent = sub;
      btn.onclick = () => {
        const subIndex = topic.subtopics.indexOf(sub);
        if(subIndex !== -1) showSubcontent(index, subIndex);
      };
      subtopicList.appendChild(btn);
    });

    rightPanel.appendChild(subtopicList);
  }

  // SHOW SUBTOPIC CONTENT (now async for Firestore)
  async function showSubcontent(topicIdx, subIdx) {
    currentTopicIndex = topicIdx;
    currentSubtopicIndex = subIdx;
    const topic = topics[topicIdx];
    const subtopicName = topic.subtopics[subIdx];

    document.getElementById('current-topic-header').textContent = `${topic.name} > ${subtopicName}`;

    rightPanel.innerHTML = ''; // Clear previous content

    // Subtopic heading
    const subtopicHeader = document.createElement('h2');
    subtopicHeader.textContent = subtopicName;
    rightPanel.appendChild(subtopicHeader);

    // Load from Firestore
    let savedContent = "<p>Write your notes here...</p>";
    try {
      const ref = window._doc(window._db, "notes", `${topic.name}-${subtopicName}`);
      const snap = await window._getDoc(ref);

      if (snap.exists()) {
        savedContent = snap.data().content;
      }
    } catch (e) {
      console.error("Error loading from Firestore:", e);
    }

    if (editingUnlocked) {
        // Create Quill editor structure
        const editorContainer = document.createElement('div');
        editorContainer.className = 'editor-container'; // A wrapper for Quill

        const toolbarDiv = document.createElement('div');
        toolbarDiv.id = 'quill-toolbar'; // ID for Quill to target as toolbar
        toolbarDiv.innerHTML = `
          <span class="ql-formats">
            <select class="ql-header">
              <option value="1"></option>
              <option value="2"></option>
              <option value="3"></option>
              <option selected></option>
            </select>
            <button class="ql-bold"></button>
            <button class="ql-italic"></button>
            <button class="ql-underline"></button>
            <button class="ql-strike"></button>
          </span>
          <span class="ql-formats">
            <button class="ql-list" value="ordered"></button>
            <button class="ql-list" value="bullet"></button>
            <button class="ql-indent" value="-1"></button>
            <button class="ql-indent" value="+1"></button>
          </span>
          <span class="ql-formats">
            <button class="ql-link"></button>
            <button class="ql-image"></button>
          </span>
        `;

        const editorDiv = document.createElement('div');
        editorDiv.id = 'quill-editor'; // ID for Quill to target as editor content

        editorContainer.appendChild(toolbarDiv);
        editorContainer.appendChild(editorDiv);

        rightPanel.appendChild(editorContainer); // Append the main editor container

        // Save icon SVG - placed INSIDE editorContainer
        const saveIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        saveIcon.setAttribute("viewBox", "0 0 24 24");
        saveIcon.setAttribute("class", "save-icon");
        saveIcon.innerHTML = `
          <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
          <polyline points="17 21 17 13 7 13 7 21"/>
          <polyline points="7 3 7 8 15 8"/>
        `;
        saveIcon.style.display = 'block'; // Always show when in editing mode

        // SAVE BUTTON LOGIC (Firestore)
        saveIcon.onclick = async () => {
          if (quillEditor) {
            const htmlContent = quillEditor.root.innerHTML;

            try {
              await window._setDoc(
                window._doc(window._db, "notes", `${topic.name}-${subtopicName}`),
                { content: htmlContent }
              );
            } catch (e) {
              console.error("Error saving to Firestore:", e);
            }
          }

          // Visual feedback
          saveIcon.style.fill = 'blue';
          setTimeout(() => {
            saveIcon.style.fill = 'var(--accent-green)';
          }, 500);
        };

        editorContainer.appendChild(saveIcon); // Append to the editorContainer

        // Initialize Quill editor
        quillEditor = new Quill('#quill-editor', {
          modules: {
            toolbar: '#quill-toolbar'
          },
          theme: 'snow',
          readOnly: false, // Ensure it's editable when editing is unlocked
          placeholder: 'Start writing your notes here...',
          formats: [
            'bold', 'italic', 'underline', 'strike',
            'header', 'list', 'indent', 'link', 'image'
          ]
        });

        // Load content into Quill
        quillEditor.root.innerHTML = savedContent;

        // Adjust font family within Quill's editor area
        quillEditor.root.style.fontFamily = "'Poppins', sans-serif";
        quillEditor.root.style.fontSize = "1.05em";
        quillEditor.root.style.lineHeight = "1.7";
        quillEditor.root.style.color = "var(--text-color)";

    } else {
        // If not in editing mode, display content in a read-only div
        if (quillEditor) { // Ensure quillEditor is nullified when switching modes
            quillEditor = null;
        }

        const readOnlyDiv = document.createElement('div');
        readOnlyDiv.className = 'read-only-content';
        readOnlyDiv.innerHTML = savedContent; // Display the raw HTML content
        rightPanel.appendChild(readOnlyDiv);
    }
  }

  // RENAME/REMOVE/ADD functions
  function renameTopic(topicIdx){
    if(!editingUnlocked){
      alert('Unlock editing first!');
      return;
    }
    const oldName = topics[topicIdx].name;
    let newName = prompt('Rename topic:', oldName);
    if(newName === null) return;
    const trimmed = newName.trim();
    if(trimmed === ''){
      alert('Topic name cannot be empty.');
      return;
    }
    if(topics.some((t,i) => i !== topicIdx && t.name.toLowerCase() === trimmed.toLowerCase())){
      alert('A topic with this name already exists.');
      return;
    }

    topics[topicIdx].subtopics.forEach(sub => {
      const oldKey = `subtopic-${oldName}-${sub}`;
      const newKey = `subtopic-${trimmed}-${sub}`;
      const content = localStorage.getItem(oldKey);
      if(content !== null){
        localStorage.setItem(newKey, content);
        localStorage.removeItem(oldKey);
      }
    });

    topics[topicIdx].name = trimmed;
    saveTopics();
    renderSidebar();

    if(currentTopicIndex === topicIdx){
      if (currentSubtopicIndex !== null) {
          showSubcontent(topicIdx, currentSubtopicIndex);
      } else {
        loadTopic(topicIdx);
      }
    }
  }

  function removeTopic(topicIdx){
    if(!editingUnlocked){
      alert('Unlock editing first!');
      return;
    }
    const topic = topics[topicIdx];
    if (!confirm(`Are you sure you want to delete the topic "${topic.name}" and all its subtopics? This action cannot be undone.`)){
        return;
    }
    topic.subtopics.forEach(sub => {
      localStorage.removeItem(`subtopic-${topic.name}-${sub}`);
    });

    topics.splice(topicIdx, 1);
    saveTopics();
    renderSidebar();

    if(currentTopicIndex === topicIdx){
      currentTopicIndex = null;
      currentSubtopicIndex = null;
      document.getElementById('current-topic-header').textContent = 'Select a topic';
      rightPanel.innerHTML = '';
      if (quillEditor) {
        quillEditor = null;
      }
    } else if (currentTopicIndex > topicIdx) {
        currentTopicIndex--;
        if (currentTopicIndex !== null) {
            if (currentSubtopicIndex !== null && topics[currentTopicIndex] && topics[currentTopicIndex].subtopics[currentSubtopicIndex]) {
                showSubcontent(currentTopicIndex, currentSubtopicIndex);
            } else {
                loadTopic(currentTopicIndex);
            }
        }
    }
  }

  function addTopic(){
    if(!editingUnlocked){
      alert('Unlock editing first!');
      return;
    }
    let newName = prompt('Enter new topic name:');
    if(newName === null) return;
    newName = newName.trim();
    if(newName === ''){
      alert('Topic name cannot be empty.');
      return;
    }
    if(topics.some(t => t.name.toLowerCase() === newName.toLowerCase())){
      alert('A topic with this name already exists.');
      return;
    }
    topics.push({ name: newName, subtopics: [] });
    saveTopics();
    renderSidebar();
    const newTopicIndex = topics.length - 1;
    loadTopic(newTopicIndex);
    toggleSubtopics(`sub${newTopicIndex}`);
  }

  function addSubtopic(topicIdx){
    if(!editingUnlocked){
      alert('Unlock editing first!');
      return;
    }
    let newSub = prompt('Enter new subtopic name:');
    if(newSub === null) return;
    newSub = newSub.trim();
    if(newSub === ''){
      alert('Subtopic name cannot be empty.');
      return;
    }
    if(topics[topicIdx].subtopics.some(s => s.toLowerCase() === newSub.toLowerCase())){
      alert('A subtopic with this name already exists in this topic.');
      return;
    }
    topics[topicIdx].subtopics.push(newSub);
    saveTopics();
    renderSidebar();
    const dropdown = document.getElementById(`sub${topicIdx}`);
    if(dropdown) dropdown.style.display = 'block';
    const newSubtopicIndex = topics[topicIdx].subtopics.length - 1;
    showSubcontent(topicIdx, newSubtopicIndex);
  }

  function renameSubtopic(topicIdx, subIdx){
    if(!editingUnlocked){
      alert('Unlock editing first!');
      return;
    }
    const oldName = topics[topicIdx].subtopics[subIdx];
    let newName = prompt('Rename subtopic:', oldName);
    if(newName === null) return;
    const trimmed = newName.trim();
    if(trimmed === ''){
      alert('Subtopic name cannot be empty.');
      return;
    }
    if(topics[topicIdx].subtopics.some((s,i) => i !== subIdx && s.toLowerCase() === trimmed.toLowerCase())){
      alert('A subtopic with this name already exists in this topic.');
      return;
    }

    const oldKey = `subtopic-${topics[topicIdx].name}-${oldName}`;
    const newKey = `subtopic-${topics[topicIdx].name}-${trimmed}`;
    const content = localStorage.getItem(oldKey);
    if(content !== null){
      localStorage.setItem(newKey, content);
      localStorage.removeItem(oldKey);
    }

    topics[topicIdx].subtopics[subIdx] = trimmed;
    saveTopics();
    renderSidebar();

    if(currentTopicIndex === topicIdx && currentSubtopicIndex === subIdx){
      showSubcontent(topicIdx, subIdx);
    }
  }

  function removeSubtopic(topicIdx, subIdx){
    if(!editingUnlocked){
      alert('Unlock editing first!');
      return;
    }
    const subName = topics[topicIdx].subtopics[subIdx];
    if (!confirm(`Are you sure you want to delete the subtopic "${subName}"? This action cannot be undone.`)){
        return;
    }
    localStorage.removeItem(`subtopic-${topics[topicIdx].name}-${subName}`);

    topics[topicIdx].subtopics.splice(subIdx, 1);
    saveTopics();
    renderSidebar();

    if(currentTopicIndex === topicIdx && currentSubtopicIndex === subIdx){
      currentSubtopicIndex = null;
      rightPanel.innerHTML = '';
      document.getElementById('current-topic-header').textContent = topics[topicIdx].name;
      if (quillEditor) {
        quillEditor = null;
      }
    } else if (currentTopicIndex === topicIdx && currentSubtopicIndex > subIdx) {
        currentSubtopicIndex--;
        if (currentSubtopicIndex !== null && topics[topicIdx].subtopics[currentSubtopicIndex]) {
            showSubcontent(topicIdx, currentSubtopicIndex);
        } else {
            loadTopic(topicIdx);
        }
    }
  }

  // Toggle edit mode & password prompt
  function toggleEditMode(){
    if(editingUnlocked){
      editingUnlocked = false;
      editToggleBtn.textContent = 'Edit';
      passwordPrompt.classList.remove('visible');
      updateEditingState();
    } else {
      passwordPrompt.classList.add('visible');
      passwordInput.value = '';
      passwordError.textContent = '';
      passwordInput.focus();
    }
  }

  function checkPassword(){
    if(passwordInput.value === EDIT_PASSWORD){
      editingUnlocked = true;
      editToggleBtn.textContent = 'Lock';
      passwordPrompt.classList.remove('visible');
      passwordInput.value = '';
      passwordError.textContent = '';
      updateEditingState();
    } else {
      passwordError.textContent = 'Incorrect password, try again.';
      passwordInput.focus();
    }
  }

  function updateEditingState(){
    renderSidebar();

    // Re-show the current content to trigger Quill init/destroy logic correctly
    if (currentTopicIndex !== null && currentSubtopicIndex !== null) {
        showSubcontent(currentTopicIndex, currentSubtopicIndex);
    } else if (currentTopicIndex !== null) {
        loadTopic(currentTopicIndex);
    } else {
        // If no subtopic is selected, ensure Quill is null
        quillEditor = null;
        rightPanel.innerHTML = ''; // Clear right panel if no content selected
    }
  }

  // Clicking outside password box closes prompt
  passwordPrompt.onclick = e => {
    if(e.target === passwordPrompt){
      passwordPrompt.classList.remove('visible');
      passwordError.textContent = '';
    }
  };

  document.addEventListener('contextmenu', function(e) {
      if (e.target.closest('.topic-button') || e.target.closest('.subtopic-button')) {
          e.preventDefault();
      }
  });

  // Initialization
  function init() {
    loadTopics();
    renderSidebar();
    updateEditingState();
    addTopicBtn.onclick = addTopic;

    if (topics.length > 0) {
      loadTopic(0);
      toggleSubtopics(`sub0`);
    }
  }

  window.onload = init;
</script>
</body>
</html>
